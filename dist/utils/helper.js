"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chunks = exports.throttle = exports.createHash = exports.Deferred = exports.dpc = exports.UID = exports.now = exports.KAS = exports.sha256 = exports.Decimal = void 0;
const crypto_js_1 = __importDefault(require("crypto-js"));
const decimal_js_1 = require("decimal.js");
Object.defineProperty(exports, "Decimal", { enumerable: true, get: function () { return decimal_js_1.Decimal; } });
const sha256 = (str) => {
    return crypto_js_1.default.SHA256(str).toString(crypto_js_1.default.enc.Hex);
};
exports.sha256 = sha256;
const KAS = (v) => {
    var [int, frac] = (new decimal_js_1.Decimal(v)).mul(1e-8).toFixed(8).split('.');
    int = int.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    frac = frac === null || frac === void 0 ? void 0 : frac.replace(/0+$/, '');
    return frac ? `${int}.${frac}` : int;
};
exports.KAS = KAS;
exports.now = Date.now || function () {
    return new Date().getTime();
};
const UID = (join = '') => (0, exports.now)() + join + (Math.random() * 100000).toFixed(0);
exports.UID = UID;
const dpc = (delay, fn) => {
    if (typeof delay == 'function') {
        let temp = fn;
        fn = delay;
        delay = temp;
    }
    return setTimeout(fn, delay || 0);
};
exports.dpc = dpc;
const Deferred = () => {
    let methods = {};
    let promise = new Promise((resolve, reject) => {
        methods = { resolve, reject };
    });
    Object.assign(promise, methods);
    return promise;
};
exports.Deferred = Deferred;
const createHash = (str) => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash &= hash; // Convert to 32bit integer
    }
    //console.log("hash", str, hash)
    return new Uint32Array([hash])[0].toString(36);
};
exports.createHash = createHash;
// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
const throttle = (func, wait, options = {}) => {
    let timeout, context, args, result;
    let previous = 0;
    let later = function () {
        previous = options.leading === false ? 0 : (0, exports.now)();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
            context = args = null;
    };
    let throttled = function () {
        let _now = (0, exports.now)();
        if (!previous && options.leading === false)
            previous = _now;
        let remaining = wait - (_now - previous);
        //@ts-ignore
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = _now;
            result = func.apply(context, args);
            if (!timeout)
                context = args = null;
        }
        else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
        return result;
    };
    //@ts-ignore
    throttled.cancel = function () {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
    };
    return throttled;
};
exports.throttle = throttle;
const chunks = (list, size) => {
    return list.length ? [list.slice(0, size), ...(0, exports.chunks)(list.slice(size), size)] : [];
};
exports.chunks = chunks;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vdXRpbHMvaGVscGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDBEQUFpQztBQUNqQywyQ0FBcUM7QUFDN0Isd0ZBREMsb0JBQU8sT0FDRDtBQUVSLE1BQU0sTUFBTSxHQUFHLENBQUMsR0FBVSxFQUFDLEVBQUU7SUFDaEMsT0FBTyxtQkFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsbUJBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUE7QUFDMUQsQ0FBQyxDQUFBO0FBRlksUUFBQSxNQUFNLFVBRWxCO0FBRU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFRLEVBQVUsRUFBRTtJQUNwQyxJQUFJLENBQUMsR0FBRyxFQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxvQkFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsdUJBQXVCLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDaEQsSUFBSSxHQUFHLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLENBQUMsS0FBSyxFQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQy9CLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ3pDLENBQUMsQ0FBQTtBQUxZLFFBQUEsR0FBRyxPQUtmO0FBRVksUUFBQSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsSUFBSTtJQUMzQixPQUFPLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDaEMsQ0FBQyxDQUFBO0FBRU0sTUFB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QUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBQSxjQUFNLEVBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7QUFDdEYsQ0FBQyxDQUFBO0FBRlksUUFBQSxNQUFNLFVBRWxCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENyeXB0b0pTIGZyb20gJ2NyeXB0by1qcyc7XG5pbXBvcnQgeyBEZWNpbWFsIH0gZnJvbSAnZGVjaW1hbC5qcyc7XG5leHBvcnQge0RlY2ltYWx9O1xuXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gKHN0cjpzdHJpbmcpPT57XG4gICAgcmV0dXJuIENyeXB0b0pTLlNIQTI1NihzdHIpLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5IZXgpXG59XG5cbmV4cG9ydCBjb25zdCBLQVMgPSAodjpudW1iZXIpOiBzdHJpbmcgPT57XG4gICAgdmFyIFtpbnQsZnJhY10gPSAobmV3IERlY2ltYWwodikpLm11bCgxZS04KS50b0ZpeGVkKDgpLnNwbGl0KCcuJyk7XG4gICAgaW50ID0gaW50LnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiLFwiKTtcbiAgICBmcmFjID0gZnJhYz8ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgcmV0dXJuIGZyYWMgPyBgJHtpbnR9LiR7ZnJhY31gIDogaW50O1xufVxuXG5leHBvcnQgY29uc3Qgbm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuXG5leHBvcnQgY29uc3QgVUlEID0gKGpvaW49JycpPT5ub3coKStqb2luKyhNYXRoLnJhbmRvbSgpKjEwMDAwMCkudG9GaXhlZCgwKTtcblxuZXhwb3J0IGNvbnN0IGRwYyA9IChkZWxheTogbnVtYmVyIHwgRnVuY3Rpb24sIGZuID8gOiBGdW5jdGlvbiB8IG51bWJlcikgPT4ge1xuICAgIGlmICh0eXBlb2YgZGVsYXkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsZXQgdGVtcCA9IGZuIGFzIG51bWJlcjtcbiAgICAgICAgZm4gPSBkZWxheTtcbiAgICAgICAgZGVsYXkgPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gc2V0VGltZW91dChmbiBhcyBGdW5jdGlvbiwgZGVsYXkgfHwgMCk7XG59XG5leHBvcnQgaW50ZXJmYWNlIERlZmVycmVkUHJvbWlzZSBleHRlbmRzIFByb21pc2U8YW55PiB7XG4gICAgcmVzb2x2ZShkYXRhPzphbnkpOnZvaWQ7XG4gICAgcmVqZWN0KGVycm9yPzphbnkpOnZvaWQ7XG59XG5leHBvcnQgY29uc3QgRGVmZXJyZWQgPSAoKTogRGVmZXJyZWRQcm9taXNlPT57XG4gICAgbGV0IG1ldGhvZHMgPSB7fTtcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIG1ldGhvZHMgPSB7cmVzb2x2ZSwgcmVqZWN0fTtcbiAgICB9KVxuICAgIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwgbWV0aG9kcyk7XG4gICAgcmV0dXJuIHByb21pc2UgYXMgRGVmZXJyZWRQcm9taXNlO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlSGFzaCA9IChzdHI6c3RyaW5nKSA9PiB7XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNoYXI7XG4gICAgICAgIGhhc2ggJj0gaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coXCJoYXNoXCIsIHN0ciwgaGFzaClcbiAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KFtoYXNoXSlbMF0udG9TdHJpbmcoMzYpO1xufTtcblxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4vLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbi8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbi8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4vLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbmV4cG9ydCBjb25zdCB0aHJvdHRsZSA9IChcbiAgICBmdW5jOiBGdW5jdGlvbiwgd2FpdDogbnVtYmVyLCBvcHRpb25zOiBcbiAgICB7bGVhZGluZz86Ym9vbGVhbiwgdHJhaWxpbmc/OmJvb2xlYW59ID0ge31cbikgPT4ge1xuICAgIGxldCB0aW1lb3V0OiBhbnksIGNvbnRleHQ6IGFueSwgYXJnczogYW55LCByZXN1bHQ6IGFueTtcbiAgICBsZXQgcHJldmlvdXMgPSAwO1xuXG4gICAgbGV0IGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBub3coKTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dClcbiAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgbGV0IHRocm90dGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgX25vdyA9IG5vdygpO1xuICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICBwcmV2aW91cyA9IF9ub3c7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSB3YWl0IC0gKF9ub3cgLSBwcmV2aW91cyk7XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBfbm93O1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dClcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBwcmV2aW91cyA9IDA7XG4gICAgICAgIHRpbWVvdXQgPSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiB0aHJvdHRsZWQ7XG59XG5cbmV4cG9ydCBjb25zdCBjaHVua3MgPSAobGlzdDphbnlbXSwgc2l6ZTpudW1iZXIpOiAoYW55W10pW109PntcbiAgICByZXR1cm4gbGlzdC5sZW5ndGggPyBbbGlzdC5zbGljZSgwLCBzaXplKSwgLi4uY2h1bmtzKGxpc3Quc2xpY2Uoc2l6ZSksIHNpemUpXSA6IFtdXG59Il19